## 문제 설명

스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다.

속한 노래가 많이 재생된 장르를 먼저 수록합니다.
장르 내에서 많이 재생된 노래를 먼저 수록합니다.
장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.
노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요.

## 제한사항

genres[i]는 고유번호가 i인 노래의 장르입니다.
plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다.
genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다.
장르 종류는 100개 미만입니다.
장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다.
모든 장르는 재생된 횟수가 다릅니다.

## 문제 해결

```swift
import Foundation

func programmers_week1_3(_ genres:[String], _ plays:[Int]) -> [Int] {
    // 장르, 재생 횟수 역순 배치 -> 시간 복잡도를 위함
    var genres = Array(genres.reversed())
    var plays = Array(plays.reversed())

    // [장르: [(고유번호, 재생 횟수)]] 형태의 딕셔너리 선언
    var dict = [String: [(index: Int, playTime: Int)]]()

    // 딕셔너리 내용물 구현
    for index in 0..<genres.count {
        // 시간 복잡도를 위한 removeLast()
        let genre = genres.removeLast()
        let playTime = plays.removeLast()

        // 해당 장르의 이전 value([(고유번호, 재생 횟수)])를 가져옴
        var lastStored = dict[genre] ?? []
        // value 최신화
        lastStored.append((index: index, playTime: playTime))
        // 딕셔너리 최신화
        dict[genre] = lastStored
    }

    // [(총 재생 횟수, 재생 빈도 Top2Top2 노래 인덱스 배열)] 배열 생성
    var array = [(totalPlayTime: Int, indexArr: [Int])]()

    // 이전에 생성한 딕셔너리 순회
    for key in dict.keys {
        // 해당 장르의 [(고유번호, 재생 횟수)] 배열 가졍괴
        let arr = dict[key]!
        
        // 재생 횟수가 많은 순으로 정렬
        // 재생 횟수 동일시 인덱스가 낮은 순으로 정렬
        let answerArr = arr.sorted(by: { prev, next in
            return prev.playTime > next.playTime || (prev.playTime == next.playTime && prev.index < next.index)
        })

        // 재생 횟수 Top2 노래의 고유 번호 배열
        // .prefix() 메서드를 사용하여야
        // 배열의 개수가 2개 미만이어도 오류없이 잘 가져옴
        let indexArr = answerArr.prefix(2).map { $0.index }

        // 장르별 전체 재생 횟수
        var totalPlayTime = 0

        // 재생 횟수 계산
        answerArr.forEach {
            totalPlayTime += $0.playTime
        }
        // reduce로도 가능
//        let totalPlayTime = answerArr.reduce(0) { $0 + $1.playTime }

        // (총 재생 횟수, 재생 빈도 Top2Top2 노래 인덱스 배열) 튜플 완성
        let target = (totalPlayTime, indexArr)

        // 배열에 추가
        array.append(target)
    }

    // 재생 횟수가 많은 장르 순으로 정렬
    // [[4, 1], [3, 0]]과 같은 형태로 저장되어 있기에 flatMap
    let ans = array.sorted { $0.totalPlayTime > $1.totalPlayTime }.flatMap { $0.indexArr }

    // 정답 반환
    return ans
}
```

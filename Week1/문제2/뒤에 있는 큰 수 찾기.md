## 문제 설명

정수로 이루어진 배열 numbers가 있습니다. 배열 의 각 원소들에 대해 자신보다 뒤에 있는 숫자 중에서 자신보다 크면서 가장 가까이 있는 수를 뒷 큰수라고 합니다.
정수 배열 numbers가 매개변수로 주어질 때, 모든 원소에 대한 뒷 큰수들을 차례로 담은 배열을 return 하도록 solution 함수를 완성해주세요. 단, 뒷 큰수가 존재하지 않는 원소는 -1을 담습니다.

## 제한사항

4 ≤ numbers의 길이 ≤ 1,000,000
1 ≤ numbers[i] ≤ 1,000,000

## 문제 해결

```swift
import Foundation

func programmers_week1_2(_ numbers: [Int]) -> [Int] {
    // 결과로 반환할 정수 배열을 먼저 모두 뒤큰수가 없다고 가정하여 -1로 채움
    var answer = Array(repeating: -1, count: numbers.count)

    // 시간 복잡도를 줄이기 위해 스택을 활용
    var stack: [Int] = []

    // 뒤의 큰 수를 구하는 문제이기 때문에 뒤에서부터 접근
    for i in stride(from: numbers.count - 1, through: 0, by: -1) {
        // 먼저 스택이 비어있지 않을때까지 반복
        // 스택이 빈다면 결국 뒤에 큰 수는 발견 못한거니 -1 그대로 유지
        // 다음으로, 스택의 가장 뒤에 있는 값은
        // 현재 기준으로 삼고 있는 숫자와 가장 가까운 숫자
        // 만약 기준 숫자가 스택의 마지막 숫자보다 작다면 그것이 바로 뒤의 큰 수
        // 그렇지 않다면 현재 기준 숫자가 더 큰 것이니 스택에 쌓인 다음 가장 가까운 수를 살펴봄
        // 그리고 그 스택의 마지막 숫자는 제거 해도 무방
        // 그 이유는 예시로 알아보도록 한다.
        // 알아보야할 숫자들이 [7, 5]
        // 현재 스택에 쌓인 수가 [6, 2]라면
        // 5는 2보다 크므로 스택에 2를 제거해야 함
        // 그럼 스택에 쌓인 수는 [6] 이고 5보다 큰 수이니 스택은 [6, 5]가 된다
        // 어차피 7의 입장에서 자신보다 작은 숫자인 6 보다 작은 숫자이니 보나마나!
        // 즉 시간 낭비!
        // 그리고 위의 예시에서 볼 수 있듯, 스택에 쌓인 수는 오름 차순으로 쌓일 것이다!
        while !stack.isEmpty && stack.last! <= numbers[i] {
            stack.removeLast()
        }

        // 스택의 마지막 숫자가 있다는 것은
        // 현재 숫자보다 큰 숫자가 스택에 있다는 뜻!
        // 그러므로 그것이 바로 타겟 숫자의 뒤의 큰 수!
        if let last = stack.last {
            answer[i] = last
        }

        // 그리고 현재까지 다룬 타겟 숫자도 스택에 넣어서,
        // 다음 반복에서 이전 인덱스의 숫자와 비교할 수 있게 만듦
        stack.append(numbers[i])
    }

    return answer
}
```
